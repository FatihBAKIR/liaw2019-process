

#+Revision: 0
#+Audience: LEWGI
#+Status: 
#+Group: WG21
#+Title: A proposal to add process management to the C++ standard library
#+Author: 
#+Email: jeff@crystalclearsoftware.com

* Revision History
** Revision 0
Initial release.

* Introduction

The creation and management of processes is a widely used and fundamental tool in computing systems.  Unfortunately, C++ does not have a portable way to create and manage processes. Most other language standard libraries support facilities to wrap the complexities in support of application programmers. The functionality has been on standard library wishlists going back to 2007 (Matt Austern ref below).

The proposal is based on boost.process https://www.boost.org/libs/process which provides cross-platform implementation experience.

* Motivation and Scope

We propose a library to facilitate the following basic functionality:
+    create child processes on the current machine
+    setup streams for communication with child stdout and stderr
+    communicate with child processes through streams
+    wait for processes to exit 
+    terminate processes
+    capture the return result of a child process
+    manage groups of processes
+    optionally associate the child-process to the parent-child to children die with their parents, but not vice-versa.

The following illustrates an example usage of the proposed library. 

#+BEGIN_SRC c++

#include <process>

int main()
{
  std::vector<std::string> args { "--version", "--std=c++2a" };

  try {
    std::ipstream pipe_stream;
    std::process child("gcc", args,
        std::process_io({}, pipe_stream, {})); //capture stdout, leave the others as the OS defaults

    std::string line;

    while (pipe_stream && std::getline(pipe_stream, line) && !line.empty()) 
    {
      std::cerr << line << std::endl;
    }
    child.wait();
  }
  catch(const std::process_error& e) 
  {
    std::cerr << e.what();
  }
}

#+END_SRC

* Domain Terminology
** Processes
A process is an instance of a program in execution. A process has at least one thread. A process starts execution in the thread that invokes its main function. A child process is the result of another process creating or spawning the child. 

** Process Groups
Process groups allow for managing a set of processes at the operating system level. This allows behavior such as process termination to be automatically coordinated by the operating system. For example, child processes in a group can be set to terminate together.

** Pipes
A pipe is a unidirectional, serial communication line across processes. A pipe has two ends: a write end and a read end.

A pipe is buffered. The size of the buffer is implementation defined. When there's no data in the buffer, the pipe is called empty. When the buffer is full, the pipe is called full.

Reading from an empty pipe is a blocking operation. Writing to a pipe resumes any blocked threads that are waiting to read on that pipe.

Writing to a full pipe is a blocking operation. Reading from a pipe resumes any blocked threads that are writing to that pipe.

If there are multiple threads reading or writing from the same pipe at the same time the order in which they read the data is unspecified.

** Environment and Command Line Arguments

Creation of a child process sometimes involves modifying the environment for the child process. This proposal references a current proposal for referencing a process environment. However, the proposal P1275 (see References in the bottom) would need to be enhanced to support multiple instances of environments for access and modification of child process environment.

This proposal currently contains a synopsis of similar functionality.

* Use Cases
* Survey of facilities in other standard libraries
** C/C++ system function

C and C++ currently provide a minimal process launching capability via the =system= function. The C++ function takes a =const char*= parameter that represents the command string to execute and an integer return code that signifies the execution return status. 

#+BEGIN_SRC c++

int result = system("echo \"foo\" > bar.txt");
if (result == 0) {
  //success
}

#+END_SRC

This minimal facility lacks many aspects of process control needed for even basic applications, including access to the standard streams (stdin, stdout, stderr) of the child.

In addition it uses the system shell to interpret the command, which is a huge security hazard because of shell injection.

** Java
Java provides a ProcessBuilder and stream piping facilities similar to what is proposed here. 

#+BEGIN_SRC java

// ProcessBuilder takes variadic string arguments
// or a List<String>
var builder = new ProcessBuilder("/bin/cat", "-");

// start()-method will spawn the process
// Standard streams are piped automatically
Process p = builder.start();

// Write into process stdin
new OutputStreamWriter(p.getOutputStream())
      .write("foo\n")
      .close(); // close() needed to flush the buffer

// Read from stdout
var reader = new BufferedReader(
                  new InputStreamReader(p.getInputStream()));
String output = reader.readLine();

assert output == "foo";

System.out.println("Exited with " + p.exitValue())

#+END_SRC

** Python

#+BEGIN_SRC python
from subprocess import Popen, PIPE

# Command line arguments are all passed in a single list
# Standard streams aren't piped by default
child = Popen([ '/bin/cat', '-' ],
          stdin=PIPE, stdout=PIPE, stderr=PIPE)

# communicate() takes input (optional)
# Waits for process to terminate
# Handles to standard streams aren't available
out, err = child.communicate(input='foo\n')
assert out == 'foo'
print("Exited with", child.returncode)

#+END_SRC

** Rust
As with other languages Rust provides the ability to pipe the results of the process into the parent.

#+BEGIN_SRC rust
use std::process::{Command, Stdio};

let mut child = Command("/bin/cat")
                .arg("-") // .args() also available, taking a range
                          // strings passed to .arg() are escaped
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .spawn()?; // ?-operator is for error handling
child.stdin.as_mut()?.write_all(b"foo\n")?;
// .wait_with_output() will, well, wait
// child.stdout/stderr exposes standard streams directly
let output = child.wait_with_output()?;
assert_eq!(b"foo", output.stdout.as_slice());
println!("Exited with {}", output.status.code.unwrap());

#+END_SRC

** Nodejs

#+BEGIN_SRC js

const { spawn } = require('child_process');

// First argument is argv[0], rest of argv passed in a list
const p = spawn('/bin/cat', ['-']);
p.stdin.write('foo\n');
// Idiomatic node.js uses callbacks everywhere
p.stdout.on('data', (data) => {
  assert.StrictEqual(data, 'foo\n');
});
p.on('close', (code) => {
  console.log(`Exited with ${code}`);
});

#+END_SRC

* Design 

** Core language impact
Bryce to provide information to Jeff

** Namespace std versus std::process

The classes and functions for this proposal could be put into namespace =std=, or a sub-namespace, such as =std::process=. Process is more similar to =std::thread= than =std::filesystem=. Since thread is in namespace =std= this proposal suggests the same for process.

** Start of execution on process create
TODO

** Using a builder method to create

Have a =run()= method versus immediate launching in the constructor

This is solved through the extended launcher concept. 

#+BEGIN_SRC c++

// These are the same:
process(...) : process(process_launcher.launch(...)) {}
process_launcher().launch(...) -> process;

// These are the same:
process(..., custom_launcher & cl) : process(cl.launch) {}
cl.launch(...);

#+END_SRC

** Handling of parameters
  - There's an issue of escaping the argument properly
  - see issues below on P1275

** ~wait~ or ~join~
TODO

** Native Operating System Handle

The solution provides access to the operating system, like =std::thread=, for programmers who to go beyond the provided facilities.

** Portable callbacks during spawn

*** on_error

On error passes an std::error_code to the initializer, so it can react, e.g. free up resources. The launcher must only throw after every initializer was notified.

*** on_success
TODO
*** on_setup
TODO

** EOF on pipe close

Is automatically delivered by the OS. 

** Security and User Management Implications

=std::system= is dangerous because of shell injection, which cannot happen with the uninterpreted version that is proposed here. A shell might easily still be used by utilizing =std::this_process::environment::shell()=.

The standard process library does not touch on user management, though it can be extended to support it.

** Extensibility

To be extensible this library uses two concepts: =ProcessLauncher= and =ProcessInitializer=.

A =ProcessLauncher= is the actual function creating the process. It can be used to provide platform dependent behaviour such as launching a process a new user (Using =CreateProcessAsUser= on Windows) or to use =vfork= on Linux. The vendor can thus just provide a launcher, and the user can then just drop it into their code.

A =ProcessInitializer= allows minor additions, that just manipulate the process. E.g. on Windows to set a =SHOW_WINDOW= flag, or on Linux to change the user with =setuid=.

None of this functionality should be built into the library, yet not having those customization points would greatly limit the applicability of this library.

** Error Handling

Only done by exceptions for now, by throwing a =std::process_error=.

** Synchronous Versus Asynchronous

Synchronous is very prone to deadlocks.

** Integration of iostreams and pipes

Pipes bring their own streams, that can be used within on process (e.g. between threads).

* Technical Specification
** Header ~<process>~ Synopsis

This is a first cut at the wording. We probably don't need to go much deeper in the specification than the synopsis for the first paper.  I (Jeff G) basically lifted this out of boost.process::child and updated.

#+BEGIN_SRC c++

#include <chrono>
#include <filesystem>
#include <ranges>
#include <string>
#include <system_error>
#include <vector>
 
namespace std {
  // A launcher is an object that has a launch function that takes a path, arguments and a variadic list of process initializers and returns a process object. 
  template<class T>
  concept bool ProcessLauncher = requires(T launcher) {
    {launcher.set_error(error_code(), "message")} -> void; //so initializers can post internal errors
    {launcher.launch(filesystem::path(), vector<string>())} -> process; //refine that so check tha parameter list, good enough for now.
  };
  
  // An initializer is an object that changes the behavior of a process during launch and thus listens to at least one of the hooks of the launcher. 
  //Note that the following example only uses portable hooks, but non portables might suffic as well
  template<class Init, ProcessLauncher Launcher = process_launcher>
  concept bool ProcessInitializer =
       requires(Init initializer, Launcher launcher) { {initializer.on_setup(launcher)}   -> void; }
    || requires(Init initializer, Launcher launcher) { {initializer.on_success(launcher)} -> void; }
    || requires(Init initializer, Launcher launcher) { {initializer.on_error(launcher, error_code())} -> void; };
  }

  // This is to be defined, but should allow any stream that can yield a system-handle (e.g. pipes, files & sockets) and to close the stream by passing nullptr. 
  // Additionally a path should be possible to open a file just for the child process.
  // EK: Does ProcessReadableStream mean the child can read from it, or that we can read from it?
  //     In other words, is it the child's stdin or stdout/stderr?
  concept ProcessReadableStream = TODO;
  concept ProcessWritableStream = TODO;

  // A pid_type is an identifier for a process, that satisfies StrictTotallyOrdered
  // EK: Should maybe also be TriviallyCopyable and maybe Regular?
  using pid_type = implementation-defined;

  // Provides a portable handle to an operating system process
  // process satisfies Movable and Boolean, but not Copyable.
  // EK: Add rationale for not making SemiRegular (not DefaultConstructible and Copyable)
  class process;

  // Exception type thrown on error
  class process_error;
  
  // Provides a portable wrapper for a process group
  class process_group;
  
  // Provides an initializers for the standard io. Alternative: nested as std::process::io
  class process_io;
  
  // Provides a way to set the starting directory of the new process. Alternative: nested as std::process::start_dir
  class process_start_dir;

  // Satisfies ProcessInitializer
  // EK: Change name to process_environment, to:
  //    a) prevent collisions with P1275
  //    b) avoid using a very useful name in namespace std
  class environment;
  
  // Satisfies ProcessInitializer
  class process_limit_handles;
}

#+END_SRC

** Class ~process~

#+BEGIN_SRC c++

namespace std {
  class process {
  public:
    // Provides access to underlying operating system facilities
    // EK: TriviallyCopyable? StandardLayout? (Semi)Regular? Copyable? What are the requirements?
    using native_handle_type = implementation-defined; 
  
    // Construct a child from a property list and launch it.
    template<ranges::InputRange R, ProcessInitializer... Inits>
      requires ConvertibleTo<iter_value_t<R>, string>
    explicit process(const filesystem::path& exe, const R& args, Inits&&... inits);
  
    // Construct a child from a property list and launch it with a custom process launcher
    // EK: shouldn't the argument pack be the final argument? or does this really work?
    template<ranges::InputRange R, ProcessInitializer... Inits, ProcessLauncher Launcher>
      requires ConvertibleTo<iter_value_t<R>, string>
    explicit process(const filesystem::path& exe, const R& args, Inits&&... inits, Launcher&& launcher);
  
    // Attach to an existing process
    explicit process(pid_type& pid);
  
    // An empty process is similar to a default constructed thread. It holds an empty handle and is a place holder for a process that is to be launched later.
    process() = default;
    
    // The destructor terminates 
    // EK: Add rationale for inconsistency with thread
    ~process();
  
    // Accessors 
  
    pid_type id() const;
  
    native_handle_type native_handle() const;
  
    // Return code of the process, only valid if !running()
    int exit_code() const;
  
    // Check if the process is running. If the process has exited already, it might store the exit_code internally.
    bool running() const;
  
    // Check if this handle holds a child process.
    // NOTE: That does not mean, that the process is still running. It only means, that the handle does or did exist.
    bool valid() const;
    explicit operator bool() const; // Equivalent to this->valid()
  
    // Process management functions
  
    // Detach a spawned process -- let it run after this handle destructs
    void detach();
  
    // Terminate the child process (child process will unconditionally and immediately exit)
    // TODO: Clean
    // Implemented with SIGKILL on POSIX and TerminateProcess on Windows
    void terminate();
  
    // Block until the process to exits 
    void wait();
  
    // Block for the process to exit for a period of time.
    template<class Rep, class Period>
    bool wait_for(const chrono::duration<Rep, Period>& rel_time);
  
    // wait for the process to exit until a point in time.
    template<class Clock, class Duration>
    bool wait_until(const chrono::time_point<Clock, Duration>& timeout_time);
    
    //The following is dependent on the networking TS. CompletionToken has the signature (int, error_code), i.e. wait for the process to exit and get the exit_code if exited. 
    template<class CompletionToken>
    DEDUCED async_wait(io_context& ctx, CompletionToken&& token);
  };
}

#+END_SRC

** Class ~process_error~

#+BEGIN_SRC c++

class process_error : public system_error {
public:
  using system_error::system_error;

  // EK:
  // filesystem_error can take a path relating to the error,
  // should we take a pid_type as well?
};

#+END_SRC

** Class ~process_group~

#+BEGIN_SRC c++

namespace std {
  class process_group {
  public:
    // Provides access to underlying operating system facilities
    using native_handle_type = implementation-defined; 

    process_group() = default;

    // EK: How about copy constructors?
    process_group(process_group&& lhs);
    process_group& operator=(process_group&& lhs);
    
    // The destructor terminates all processes in the group
    ~process_group();

    native_handle_type native_handle() const;

    // Check if at least one process of the group is running
    bool running() const;

    // Check if this handle holds a process group.
    // NOTE: That does not mean, that the process is still running. It only means, that the handle does or did exist.
    bool valid() const;
    explicit operator bool() const; // Equivalent to this->valid()

    // Process management functions

    // Detach a process group -- let it run after this handle destructs
    void detach();

    // Terminate the child processes (child processes will unconditionally and immediately exit)
    // TODO: Clean
    // Implemented with SIGKILL on POSIX and TerminateProcess on Windows
    void terminate();

    // Block until all processes exit
    void wait();

    // Block until one process exit
    // NOTE: Windows does not yield information on which process exited.
    void wait_one();

    // Block for all processes to exit for a period of time.
    template<class Rep, class Period>
    bool wait_for(const chrono::duration<Rep, Period>& rel_time);

    // Block for one process to exit for a period of time.
    template<class Rep, class Period>
    bool wait_for_one(const chrono::duration<Rep, Period>& rel_time);

    // Wait for all processes to exit until a point in time.
    template<class Clock, class Duration>
    bool wait_until(const chrono::time_point<Clock, Duration>& timeout_time);

    // Wait for one process to exit until a point in time.
    template<class Clock, class Duration>
    bool wait_until_one(const chrono::time_point<Clock, Duration>& timeout_time);
    
    // The following is dependent on the networking TS. CompletionToken has the signature (error_code) and waits for all processes to exit
    template<class CompletionToken>
    DEDUCED async_wait(io_context& ctx, CompletionToken&& token);

    // The following is dependent on the networking TS. CompletionToken has the signature (error_code) and waits for one process
    template<class CompletionToken>
    DEDUCED async_wait_one(io_context& ctx, CompletionToken&& token);
  };
}

#+END_SRC

** Class ~process_io~

#+BEGIN_SRC c++

namespace std {
  // This class describes I/O redirection for the standard streams (stdin, stdout, stderr).
  // They all are to be set, because Windows either inherits all or all need to be set. 
  // Satisfies ProcessInitializer
  class process_io {
  public:
    // OS dependent handle type
    using native_handle = implementation-defined;
    
    using in_default  = implementation-defined;
    using out_default = implementation-defined;
    using err_default = implementation-defined;
  
    template<ProcessReadableStream In = in_default,
             ProcessWritableStream Out = out_default,
             ProcessWritableStream Err = err_default> 
    process_io(In&& in, Out&& out, Err&& err);
    
    // Rest is implementation-defined
  };
}

#+END_SRC

** Class ~process_start_dir~

#+BEGIN_SRC c++

namespace std {
  // This class the starting directory for the child process.
  // Satisfies ProcessInitializer
  class process_start_dir {
  public:
    process_start_dir(const filesystem::path&);
  };
}

#+END_SRC

** Class ~environment~

An environment class that can manipulate and query any environment variables. Note that this is not for direct manipulation of the current processes environment, but it satisfies ProcessInitializers

#+BEGIN_SRC c++

namespace std {
  // Satisfies ProcessInitializer
  class environment {
  public:
    using native_environment_type = implementation-defined;
    
    native_environment_type native_environment();

    // Empty environment
    environment();
    
    // Construct from a native type, so the current environment can be cloned
    // EK: taken by value, so is native_environment_type cheap to copy?
    environment(native_environment_type native_environment); 
    
    class entry;
    
    using value_type = entry;

    // Note that windows uses wchar_t here, the key type should be able to be constructed from a char* though
    // So it needs to be similar to filesystem::path
    using key_type   = implementation-defined; 
    using pointer    = implementation-defined;
    
    // EK: Take by rvalue reference as well?
    value_type  get(const key_type& id);
    void        set(const key_type& id, const value_type& value);
    void      reset(const key_type& id);

    // Get all the keys
    // Return type satisfies ForwardRange with iter_value_t convertible to string
    // EK: is ForwardRange the right choice here?
    implementation-defined keys() const;
    
    // Utility functions to query common values
    
    // Home folder 
    filesystem::path home() const;
    // Temporary folder as defined in the env
    filesystem::path temp() const;
    
    // Shell command, see ComSpec for windows
    filesystem::path shell() const;
    
    // The path variable, parsed.
    // EK: Also return a range instead of vector?
    vector<filesystem::path> path() const;
    
    // The path extensions, that mark a file as executable (empty on posix)
    vector<filesystem::path> extensions() const;

    // Find an executable file with this name.
    // EK: const string& -> string_view?
    filesystem::path find_executable(const string& name);
  };

  class environment::entry {
  public:
    using value_type = implementation-defined;

    entry();

    entry& operator=(const entry&);
    entry& operator=(entry&&);
    
    string string();
    wstring wstring();
    value_type native_string();

    // Split according to the OS specifics
    // EK: Return a range?
    vector<value_type> as_vector();
    
    entry& operator=(const string&);
    entry& operator=(const wstring&);
    
    entry& operator=(const vector<value_type>&);
  };
}

#+END_SRC

** Class ~process_limit_handles~

This limit_handles property sets all properties to be inherited only expcitly. It closes all unused file-descriptors on POSIX after the fork and removes the inherit flags on Windows.

Since limit also closes the standard handles unless they are explicitly redirected, they can be ignored by =limit_handles=, through passing in =this_process::stdio()=.

#+BEGIN_SRC c++

namespace std {
  // Satisfies ProcessInitializers
  class process_limit_handles {
  public:
    // Select all the handles that should be inherited even though they are not used by any initializer.
    template<typename... Handles>
    process_limit_handles(Handles&&... handles);
  };
}

#+END_SRC

** Enhanced ~system~ details

#+BEGIN_SRC c++

// EK: Change signature; system takes a string, not an argument pack
template<class... Args>
int system(Args&&... args)
{
  // EK: Change constructor call to taking a path, arguments and something similar to shell_launcher
  // EK: also, a rogue comma at the end
  process c(forward<Args>(args)...,);
  if (!c.valid())
    return -1;
  c.wait();
  return c.exit_code();
}

#+END_SRC

** Extension of ~fstream~ 

The standard file streams (=fstream=/=ofstream=/=ifstream=) shall have a member function that return the native handle of the opened file, so that process can use those for forwarding.

EK: Also add to basic_filebuf?

#+BEGIN_SRC c++

namespace std {
  class /* basic_(o|i)*fstream */ {
    // ...
  public:
    // ...
    using native_handle_type = implementation-defined; 
    native_handle_type native_handle() const;
    // ...
  };
}

#+END_SRC

** Header ~<pstream>~ Synopsis

This is just the outline of the pipe header. It could be part of the <process> header, but pipes can be used without processes (e.g. between threads) so that it might be a good idea to have them in their own header.

#+BEGIN_SRC c++

#include <istream>
#include <ostream>
#include <streambuf>
#include <net> // Networking TS

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_pipe;

  // EK: how about u8pipe, u16pipe and u32pipe? Probably let SG16 decide
  using pipe  = basic_pipe<char>;
  using wpipe = basic_pipe<wchar_t>;
  
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_pipebuf;
  
  using pipebuf  = basic_pipebuf<char>;
  using wpipebuf = basic_pipebuf<wchar_t>;
  
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_ipstream;
  
  using ipstream  = basic_ipstream<char>;
  using wipstream = basic_ipstream<wchar_t>;
  
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_opstream;
  
  using opstream  = basic_opstream<char>;
  using wopstream = basic_opstream<wchar_t>;
  
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_pstream;
  
  using pstream  = basic_pstream<char>;
  using wpstream = basic_pstream<wchar_t>;
  
  class async_pipe;
}

#+END_SRC

** Class template ~basic_pipe~ Synopsis

#+BEGIN_SRC c++

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_pipe {
  public:
    using char_type   = CharT;
    using traits_type = Traits;

    using int_type = typename Traits::int_type;
    using pos_type = typename Traits::pos_type;
    using off_type = typename Traits::off_type;
    
    using native_handle = implementation-defined

    // Default construct the pipe. Will be opened.
    basic_pipe();

    // Construct a named pipe.
    explicit basic_pipe(const string& name);

    // Copying a pipe will duplicate the handles.
    basic_pipe(const basic_pipe& p);
    basic_pipe& operator=(const basic_pipe& p);

    basic_pipe(basic_pipe&& lhs);
    basic_pipe& operator=(basic_pipe&& lhs);

    // Destructor closes the handles
    ~basic_pipe();

    native_handle native_source() const;
    native_handle native_sink() const;

    void assign_source(native_handle h);
    void assign_sink(native_handle h);

    // Write data to the pipe.
    int_type write(const char_type* data, int_type count);
    // Read data from the pipe.
    int_type read(char_type* data, int_type count);

    // Check if the pipe is open.
    bool is_open();
    // Close the pipe
    void close();
  };
}

#+END_SRC

** Class template ~basic_pipebuf~ Synopsis

#+BEGIN_SRC c++

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_pipebuf : basic_streambuf<CharT, Traits> {
  public:
    using pipe_type = basic_pipe<CharT, Traits>;

    using char_type   = CharT;
    using traits_type = Traits;

    using int_type = typename Traits::int_type;
    using pos_type = typename Traits::pos_type;
    using off_type = typename Traits::off_type;

    constexpr static int default_buffer_size = BOOST_PROCESS_PIPE_SIZE;

    // Default constructor, will also construct the pipe.
    basic_pipebuf()
    {
      // exposition-only
      this->setp(_write.data(), _write.data() + _write.size());
    }

    basic_pipebuf(const basic_pipebuf&) = default;
    basic_pipebuf(basic_pipebuf&&) = default;

    // EK: copy assign deleted, but copy construct defaulted?
    basic_pipebuf& operator=(const basic_pipebuf&) = delete;
    basic_pipebuf& operator=(basic_pipebuf&&) = default;

    // Destructor writes the rest of the data
    ~basic_pipebuf();

    // Construct/assign from a pipe
    basic_pipebuf(const pipe_type& p);
    basic_pipebuf(pipe_type&& p);

    basic_pipebuf& operator=(pipe_type&& p);
    basic_pipebuf& operator=(const pipe_type& p);
    
    // Write characters to the associated output sequence from the put area
    int_type overflow(int_type ch = traits_type::eof()) override;
    
    // Synchronize the buffers with the associated character sequence
    int sync() override;

    // Reads characters from the associated input sequence to the get area
    int_type underflow() override;
    
    // Set the pipe of the streambuf
    void pipe(const pipe_type& p);
    void pipe(pipe_type&& p);

    // Get a reference to the pipe
    pipe_type&       pipe() &;
    const pipe_type& pipe() const &;
    pipe_type&&      pipe() &&;

    // Check if the pipe is open
    bool is_open() const;

    // Open a new pipe
    basic_pipebuf<CharT, Traits>* open();

    // Open a new named pipe
    basic_pipebuf<CharT, Traits>* open(const string& name);

    // Flush the buffer and close the pipe
    basic_pipebuf<CharT, Traits>* close();
  };
}

#+END_SRC

** Class template ~basic_ipstream~ Synopsis

#+BEGIN_SRC c++

template<class CharT, class Traits = char_traits<CharT>>
class basic_ipstream : public basic_istream<CharT, Traits> {
  public:
    using pipe_type = basic_pipe<CharT, Traits>;

    using char_type   = CharT;
    using traits_type = Traits;

    using int_type = typename Traits::int_type;
    using pos_type = typename Traits::pos_type;
    using off_type = typename Traits::off_type;

    // Get access to the underlying streambuf
    basic_pipebuf<CharT, Traits>* rdbuf() const;

    basic_ipstream();

    basic_ipstream(const basic_ipstream&) = delete;
    basic_ipstream(basic_ipstream&& lhs);

    basic_ipstream& operator=(const basic_ipstream&) = delete;
    basic_ipstream& operator=(basic_ipstream&& lhs);

    // Construct/assign from a pipe
    basic_ipstream(const pipe_type& p);
    basic_ipstream(pipe_type&& p);
    
    basic_ipstream& operator=(const pipe_type& p);
    basic_ipstream& operator=(pipe_type&& p);
    
    // Set the pipe of the streambuf
    void pipe(const pipe_type& p);
    void pipe(pipe_type&& p);

    // Get a reference to the pipe
    pipe_type&       pipe() &;
    const pipe_type& pipe() const &;
    pipe_type&&      pipe() &&;

    // Check if the pipe is open
    bool is_open() const;

    // Open a new pipe
    void open();

    // Open a new named pipe
    // EK: const string& -> string_view?
    void open(const string & name);

    // Flush the buffer and close the pipe
    void close();
};

#+END_SRC

** Class template ~basic_opstream~ Synopsis

#+BEGIN_SRC c++

namespace std {
template<class CharT, class Traits = char_traits<CharT>>
class basic_opstream : public basic_ostream<CharT, Traits> {
  public:
    using pipe_type = basic_pipe<CharT, Traits>;

    using char_type   = CharT;
    using traits_type = Traits;

    using int_type = typename Traits::int_type;
    using pos_type = typename Traits::pos_type;
    using off_type = typename Traits::off_type;

    // Get access to the underlying streambuf
    basic_pipebuf<CharT, Traits>* rdbuf() const;

    basic_opstream();
    
    basic_opstream(const basic_opstream&) = delete;
    basic_opstream(basic_opstream&& lhs);

    basic_opstream& operator=(const basic_opstream&) = delete;
    basic_opstream& operator=(basic_opstream&& lhs);
    
    // Construct/assign from a pipe
    basic_opstream(pipe_type&& p);
    basic_opstream(const pipe_type& p);
    
    basic_opstream& operator=(pipe_type&& p);
    basic_opstream& operator=(const pipe_type& p);
    
    // Set the pipe of the streambuf
    void pipe(const pipe_type& p);
    void pipe(pipe_type&& p);

    // Get a reference to the pipe
    pipe_type&       pipe() &;
    const pipe_type& pipe() const &;
    pipe_type&&      pipe() &&;

    // Open a new pipe
    void open();

    // Open a new named pipe
    void open(const string &name);

    // Flush the buffer & close the pipe
    void close();
};

#+END_SRC

** Class template ~basic_pstream~ Synopsis

#+BEGIN_SRC c++

namespace std {
  template<class CharT, class Traits = char_traits<CharT>>
  class basic_pstream : public basic_iostream<CharT, Traits> {
    mutable basic_pipebuf<CharT, Traits> _buf; // exposition-only
  public:
    using pipe_type = basic_pipe<CharT, Traits>;

    using char_type   = CharT;
    using traits_type = Traits;

    using int_type = typename Traits::int_type;
    using pos_type = typename Traits::pos_type;
    using off_type = typename Traits::off_type;

    // Get access to the underlying streambuf
    basic_pipebuf<CharT, Traits>* rdbuf() const;

    basic_pstream();
    
    basic_pstream(const basic_pstream&) = delete;
    basic_pstream(basic_pstream&& lhs);
    
    basic_pstream& operator=(const basic_pstream&) = delete;
    basic_pstream& operator=(basic_pstream&& lhs);

    // Construct/assign from a pipe
    basic_pstream(const pipe_type& p);
    basic_pstream(pipe_type&& p);
    
    basic_pstream& operator=(const pipe_type& p);
    basic_pstream& operator=(pipe_type&& p);
    
    // Set the pipe of the streambuf
    void pipe(const pipe_type& p);
    void pipe(pipe_type&& p);

    // Get a reference to the pipe.
    pipe_type&       pipe() &;
    const pipe_type& pipe() const &;
    pipe_type&&      pipe() &&;

    // Open a new pipe
    void open();

    // Open a new named pipe
    void open(const string& name);

    // Flush the buffer & close the pipe
    void close();
  };
}

#+END_SRC

** Class ~async_pipe~ Synopsis

#+BEGIN_SRC c++

namespace std {
  // The following is dependent on the networking TS
  // The namespace net is used to refer to the TS

  // Class implementing and asnychronous I/O-Object for use with the networking TEST.
  // It can be used directly with net::async_read or async_write.
  // NOTE: The object is copyable, but that does invoke a handle duplicate.
  class async_pipe {
  public:
    using native_handle_type = implementation-defined;

    // Automatically opens the pipe.
    // Initializes source and sink with the same io_context.
    // NOTE: Windows creates a named pipe here, where the name is automatically generated.
    // EK: explicit?
    async_pipe(net::io_context& ios);

    // Automatically opens the pipe.
    // Initializes source and sink with the same io_context.
    // NOTE: Windows restricts possible names.
    async_pipe(net::io_context& ios, const string& name);

    // NOTE: Windows requires a named pipe for this, if a the wrong type is used an exception is thrown.
    async_pipe(const async_pipe& lhs);

    async_pipe(async_pipe&& lhs);

    // Construct the async-pipe from a pipe.
    // NOTE: Windows requires a named pipe for this, if a the wrong type is used an exception is thrown.
    // EK: why explicit?
    template<class CharT, class Traits = char_traits<CharT>>
    explicit async_pipe(net::io_context& ios, const basic_pipe<CharT, Traits>& p);

    // @note Windows requires a named pipe for this, if a the wrong type is used an exception is thrown.
    template<class CharT, class Traits = char_traits<CharT>>
    async_pipe& operator=(const basic_pipe<CharT, Traits>& p);

    // NOTE: Duplicates the handles
    async_pipe& operator=(const async_pipe& lhs);

    async_pipe& operator=(async_pipe&& lhs);

    // Closes the pipe handles
    ~async_pipe();

    // Explicit conversion operator to basic_pipe
    template<class CharT, class Traits = char_traits<CharT>>
    explicit operator basic_pipe<CharT, Traits>() const;

    // Cancel the current asynchronous operations
    void cancel();
    void cancel_sink();
    void cancel_source();

    // Close the pipe handles
    void close();
    void close_sink();
    void close_source();

    // Check if the pipes are open
    bool is_open() const;
    bool is_sink_open() const;
    bool is_source_open() const;

    // Read some data from the handle.
    // See the Networking TS for more details.
    template<class MutableBufferSequence>
    size_t read_some(const MutableBufferSequence& buffers);

    // Write some data to the handle.
    // See the Networking TS for more details.
    template<class MutableBufferSequence>
    size_t write_some(const MutableBufferSequence & buffers);

    native_handle native_source() const;
    native_handle native_sink() const;

    // Start an asynchronous read
    template<class MutableBufferSequence,
             class ReadHandler>
    implementation-defined async_read_some(
        const MutableBufferSequence& buffers,
        ReadHandler&& handler);

    // Start an asynchronous write
    template<class ConstBufferSequence,
             class WriteHandler>
    implementation-defined async_write_some(
        const ConstBufferSequence& buffers,
        WriteHandler&& handler);
  };
}

#+END_SRC

** Header ~<this_process>~ Syopsis

This header provides information about the current process

#+BEGIN_SRC c++

#include <process>

namespace std::this_process
{
  // EK: process::native_handle_type and pid_type respectively?
  using native_handle_type = implementation-defined;
  using pid_type = implementation-defined;
  
  // Get the process id of the current process.
  pid_type get_id();
  // Get the native handle of the current process.
  native_handle_type native_handle();
  
  struct stdio_t
  {
    native_handle_type in();
    native_handle_type out();
    native_handle_type err();
  };
  
  // Get the handles to the standard streams
  stdio_t stdio();

  // Get a snapshot of all handles of the process (i.e. file descriptors on POSIX and handles on Windows) of the current process.
  // NOTE: This function might not work on certain posix systems.
  // NOTE: On Windows version older than Windows 8 this function will iterate all the system handles, meaning it might be quite slow.
  // NOTE: This functionality is utterly prone to race conditions, since other threads might open or close handles.
  vector<native_handle_type> get_handles();

  // Determines if a given handle is a a stream-handle, i.e. any handle that can be used with read and write functions.
  // Stream handles include pipes, regular files and sockets.
  bool is_stream_handle(native_handle_type handle);

  // Note that this might also be a global object, i.e. this is yet to be defined.
  namespace environment
  {
    using native_environment_type = implementation-defined;
    native_environment_type native_environment();
  
    using value_type = entry;
    using key_type   = implementation-defined; // Note that Windows uses wchar_t here, the key type should be able to be constructed from a char* though. So it needs to be similar to filesystem::path
    using pointer    = implementation-defined;
    
    value_type  get(const key_type& id);
    void        set(const key_type& id, const value_type& value);
    void      reset(const key_type& id);
  
    // Get all the keys
    // EK: see environment
    implementation-defined keys() const;
    
    // Home folder 
    filesystem::path home() const;
    // Temporary folder as defined in the env
    filesystem::path temp() const;
    
    // Shell command, see ComSpec for windows
    filesystem::path shell() const;
    
    // The path variable, parsed.
    vector<filesystem::path> path() const;
    
    // The path extensions, that marka file as executable (empty on posix)
    vector<filesystem::path> extensions() const;
  
    // Find an executable file with this name.
    filesystem::path find_executable(const string& name);
    
    class entry
    {
      entry();
      entry(const entry&);
      entry(entry&&);
    
      entry& operator=(const entry&);
      entry& operator=(entry&&);
      
      using value_type = implementation-defined;
      
      string string();
      wstring wstring();
      value_type native_string();

      // Split according to the OS specifics
      vector<value_type> as_vector();
      
      entry& operator=(const string&);
      entry& operator=(const wstring&);
      
      entry& operator=(const vector<value_type>&);
    };
  }
}

#+END_SRC

* Open Questions
** if we don't have wait_for can we still detach? 

Yes.

** Can we piggyback on the thread's forward progress stuff for process as well? Can we assume all threads on the system behave like C++ threads? (Jeff - seems doubtful -- network TS)
** probably dont need process_args class - vector<string> fine

Yes. Range<string> would be better I (Klemens) think, so we can also use std::initializer_list<std::string> as in {"foo", "bar"}

** environment and command line

Command line is ignored for now. This is a huge shell injection issue and takes a developer like 2 min. to use std::this_process::environment::shell(). Could be done as a custom launcher.

*** This proposal provides a use case for multiple instances of environment.  For process management there is the current process and child process environments -- not singleton from 1275
*** 1275 LEWGI in San Diego voted favoribly
*** From Klemens: std::this_process::environment though. That would make a few things more obvious, because we have an environment class too, that shuold just be used to set it up for the subprocess.
*** 1275 also has arguments does this work for our proposal?  The implementation is not complete for 1275. If the R1 has the environment as immutable then it will not work -- process needs to modify. 
*** args are available before main in 1275


* Acknowledgements

This proposal reflects the effort of the c++ community at C++Now 2019 and afterward. The primary participants are listed as authors on the paper, but many others participated in discussion of details during morning workshop sessions and conference breaks.  

None of this would have been possible without the work and guidance of Klemens Morgenstern, author of boost.process. 

* References
+ Isabella Muerte Desert Sessions: Improving hostile environment interactions http://wg21.link/p1275
+ boost.process documentation https://www.boost.org/libs/process 
+ Standard Library wishlist (Matt Austern) https://docs.google.com/document/d/1AC3vkOgFezPaeSZO-fvxgwzEIabw8I_seE7yFG_16Bk/preview
+ cppcast with Klemens on boost.process https://channel9.msdn.com/Shows/CppCast/Episode-72-BoostProcess-with-Klemens-Morgenstern
+ Pacific c++ Klemens on boost.process design https://www.youtube.com/watch?v=uZ4IG1OfeR0

