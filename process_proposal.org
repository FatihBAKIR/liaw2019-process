
#+Revision: 0
#+Audience: LEWGI
#+Status: 
#+Group: WG21
#+Title: A proposal to add process management to the C++ standard library
#+Author: 
#+Email: jeff@crystalclearsoftware.com

* Revision History
** Revision 0
Initial release.

* Introduction

The creation and management of processes is a widely used and fundamental tool in computing systems.  Unfortunately C++ does not have a portable way to create and manage processes.  Most other langauge standard libraries support facilities to wrap the complexities in support of application programmers.   The functionality has been on standard library wishlists going back to 2007 (Matt Austern ref below).

The proposal is based on boost.process https://www.boost.org/libs/process which provides cross-platform implementation experience.

* Motivation and Scope

We propose a library to facilitate the following basic functionality:
+    create child processes on the current machine
+    setup streams for communication with child std::out and std::err
+    communicate with child processes through streams
+    wait for processes to exit 
+    terminate processes
+    capture the return result of a child process
+    manage groups of processes
+    optionally associate the child-process to the parent-child to children die with their parents, but not vice-versa.

The following illustrates an example usage of the proposed library. 

#+BEGIN_SRC c++

#include <process>

int main()
{

  std::vector<std::string> args { "--version", "--std=c++2a" };

  try {
    std::ipstream pipe_stream;
    std::process child("gcc", args,
                              std_out > pipe_stream); //capture std::out

    std::string line;

    while (pipe_stream && std::getline(pipe_stream, line) && !line.empty()) 
    {
        std::cerr << line << std::endl;
    }
    child.wait();
  }
  catch(const std::exception& e) 
  {
     std::cerr << e.what();
  }
}

#+END_SRC

* Domain Terminology
** Processes
A process is an instance of a program in execution. A process has at least one thread. A process starts execution in the thread that invokes it's main function.  A child process is the result of another process creating or spawning the child. 

** Process Groups
Process groups allow for managing a set of processes at the operating system level. This allows behavior such as process termination to be automatically coordinated by the operating system.  For example, child processes in a group can be set to terminate together.

** Pipes
A pipe is a unidirectional, serial communication line across processes. A pipe has two ends: a write end and a read end.

A pipe is buffered. The size of the buffer is implementation defined. When there's no data in the buffer, the pipe is called empty. When the buffer is full, the pipe is called full.

Reading from an empty pipe is a blocking operation. Writing to a pipe resumes any blocked threads that are waiting to read on that pipe.

Writing to a full pipe is a blocking operation. Reading from a pipe resumes any blocked threads that are writing to that pipe.

If there are multiple threads reading or writing from the same pipe at the same time the order in which they read the data is unspecified.

** Environment and Command Line Arguments
Creation of a child process sometimes involves modifying the environment for the child process.  This proposal references a current proposal for referencing a process environment.  However, the proposal in P1275 would need to be enhance to support multiple instances of environments for access and modification of child process environment.

Isabella Muerte Desert Sessions: Improving hostile environment interactions http://wg21.link/p1275

* Use Cases
* Survey of facilities in other standard libraries
** C/C++ system function

C and C++ currently provide a minimal process launching capability via the `system` function. The C++ function takes a =const char*= parameter that represents command string to execute and an integer return code that signifies the execution return status. 

#+BEGIN_SRC c++

  int result = system("echo \"foo\" > bar.txt");
  if (result == 0) {
    //do something
#+END_SRC

This minimal facility lacks many aspects of process control needed for even basic applications including access to the std::err and std::out of the child.

#+BEGIN_SRC c++
template<typename ...Args>
inline int system(Args && ... args)
{
    std::process c(std::forward<Args>(args)...,);
    if (!c.valid())
        return -1;
    c.wait();
    return c.exit_code();
}
#+END_SRC

** Java
Java provides a ProcessBuilder and stream piping facilities similar to what is proposed here. 

#+BEGIN_SRC java

// ProcessBuilder takes variadic string arguments
// or a List<String>
var builder = new ProcessBuilder("/bin/cat", "-");

// start()-method will spawn the process
// Standard streams are piped automatically
Process p = builder.start();

// Write into process stdin
new OutputStreamWriter(p.getOutputStream())
      .write("foo\n")
      .close(); // close() needed to flush the buffer

// Read from stdout
var reader = new BufferedReader(
                  new InputStreamReader(p.getInputStream()));
String output = reader.readLine();

assert output == "foo";

System.out.println("Exited with " + p.exitValue())

#+END_SRC

** Python

#+BEGIN_SRC python
from subprocess import Popen, PIPE

# Command line arguments are all passed in a single list
# Standard streams aren't piped by default
child = Popen([ '/bin/cat', '-' ],
          stdin=PIPE, stdout=PIPE, stderr=PIPE)

# communicate() takes input (optional)
# Waits for process to terminate
# Handles to standard streams aren't available
out, err = child.communicate(input='foo\n')
assert out == 'foo'
print("Exited with", child.returncode)

#+END_SRC

** Rust
As with other languages Rust provides the ability to pipe the results of the process into the parent.

#+BEGIN_SRC rust
use std::process::{Command, Stdio};

let mut child = Command("/bin/cat")
                .arg("-") // .args() also available, taking a range
                          // strings passed to .arg() are escaped
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .spawn()?; // ?-operator is for error handling
child.stdin.as_mut()?.write_all(b"foo\n")?;
// .wait_with_output() will, well, wait
// child.stdout/stderr exposes standard streams directly
let output = child.wait_with_output()?;
assert_eq!(b"foo", output.stdout.as_slice());
println!("Exited with {}", output.status.code.unwrap());

#+END_SRC

** Nodejs
Nodejs offers the functionality through a package with similar functions to other langauges.

#+BEGIN_SRC js

const { spawn } = require('child_process');

// First argument is argv[0], rest of argv passed in a list
const p = spawn('/bin/cat', ['-']);
p.stdin.write('foo\n');
// Idiomatic node.js uses callbacks everywhere
p.stdout.on('data', (data) => {
  assert.StrictEqual(data, 'foo\n');
});
p.on('close', (code) => {
  console.log(`Exited with ${code}`);
});

#+END_SRC
* Design 
** Process Concepts

** Core language impact
Bryce to provide information to Jeff
** Header <process>
** Namespace std:: versus std::process

The classes and functions for this proposal could be put into namespace std:: or sub namespace such as std::process. Process is more similar to thread than filesystem.  Since thread is in namespace std this proposal suggests the same for process.

** Start of execution on process create
** Using a builder method to create
Have a run() method versus immediate in the constructor

** Handling of parameters
  - There's an issue of escaping the argument properly
  - see issues below on 1275
** ~wait~ or ~join~
** Native Operating System Handle

The solution provides access to the operating system like std::thread for programmers that which to go beyond the provided facilities.

** Portable callbacks during spawn
*** onError -- does this change into a non-exception
*** onSuccess
*** onSetup
** EOF on pipe close
** Security and User Management Implications

** Error Handling

** Synchronous Versus Asynchronous

** Integration of iostreams and pipes

* Technical Specification
** Header ~<process>~ Synopsis

This is a first cut at th wording. We probably don't need to go much deeper in the specification than the synopsis for the first paper.  I (Jeff G) basically lifted this out of boost.process::child and updated.

#+BEGIN_SRC c++
 
namespace std {

   //TODO add Klemens concepts here

   // TODO need to define  pid_t

   // Launches a process and waits for its exit
   template<typename ...Args>
   inline int system(Args && ...args);

   //TODO Jeff: I believe we can say that process satisfies SemiRegular -- copyable and default constructable.  It isn't regular bc we can't compare process objects

   //Provides a portable handle to an operating system process
   class process
   {
    public:
      //provides access to underlying operating system facilities
      typedef platform_specific native_handle_t; 

      // Construct a child from a property list and launch it
      template<typename ...Args>
      explicit process(Args&&...args);

      // Attach to an existing process
      explicit process(pid_t & pid);

      // TODO jeff g -- what's the use case for default construction?
      process() = default;

      process(process && lhs);
      process& operator=(process && lhs);
 
      //TODO Klemens -- I marked this noexcept -- is that a problem?
      // calls terminate if process is not detached or !running()
     ~process() noexcept;

      // Accessors 

      pid_t id()      const;

      native_handle_t native_handle() const;

      // return code of the process, only valid if !running()
      int exit_code() const;

      //see if part of a group
      bool in_group() const;
      bool in_group(std::error_code & ec) const noexcept;

      // check if the process is running.
      bool running();
      bool running(std::error_code & ec) noexcept;

      /** Check if this handle holds a child process.
       * @note That does not mean, that the process is still running. It only means, that the handle does or did exist.
     */
      bool valid() const;
      explicit operator bool() const; //equivalent to this->valid()


      //Process Management Functions

      // detach a spawned process -- let it run after this handle destructs
      void detach();

      /** TODO clean... Terminate the child process. 
      *
      *  This function will cause the child process to unconditionally and immediately exit.
      *  It is implement with [SIGKILL](http://pubs.opengroup.org/onlinepubs/009695399/functions/kill.html) on posix
      *  and [TerminateProcess](https://technet.microsoft.com/en-us/library/ms686714.aspx) on windows.
      *
      */
     void terminate();
     void terminate(std::error_code & ec) noexcept;

      // block until the process to exits 
      void wait();
      void wait(std::error_code & ec) noexcept;

      // block for the process to exit for a period of time.
      template< class Rep, class Period >
      bool wait_for  (const std::chrono::duration<Rep, Period>& rel_time);
      bool wait_for  (const std::chrono::duration<Rep, Period>& rel_time, std::error_code & ec) noexcept;

      // wait for the process to exit until a point in time.
      template< class Clock, class Duration >
      bool wait_until(const std::chrono::time_point<Clock, Duration>& timeout_time );
      bool wait_until(const std::chrono::time_point<Clock, Duration>& timeout_time, std::error_code & ec) noexcept;

    };


#+END_SRC

//TODO add additional types here

** Class ~process~
** Enhanced ~system~ details

#+BEGIN_SRC c++
template<typename ...Args>
inline int system(Args && ... args)
{
    std::process c(std::forward<Args>(args)...,);
    if (!c.valid())
        return -1;
    c.wait();
    return c.exit_code();
}
#+END_SRC

* Open Questions
** if we don't have wait_for can we still detach? 
** Can we piggyback on the thread's forward progress stuff for process as well? Can we assume all threads on the system behave like C++ threads? (Jeff - seems doubtful -- network TS)
** probably dont need process_args class - vector<string> fine
** environment and command line
*** This proposal provides a use case for multiple instances of environment.  For process management there is the current process and child process environments -- not singleton from 1275
*** 1275 LEWGI in San Diego voted favoribly
*** From Klemens: std::this_process::environment though. That would make a few things more obvious, because we have an environment class too, that shuold just be used to set it up for the subprocess.
*** 1275 also has arguments does this work for our proposal?  The implementation is not complete for 1275. If the R1 has the environment as immutable then it will not work -- process needs to modify. 
*** args are available before main in 1275


* Acknowledgements

This proposal reflects the effort of the c++ community at C++Now 2019 and afterward. The primary participants are listed as authors on the paper, but many others participated in discussion of details during morning workshop sessions and conference breaks.  

None of this would have been possible without the work and guidance of Klemens Morgenstern, author of boost.process. 

* References
+ Isabella Muerte Desert Sessions: Improving hostile environment interactions http://wg21.link/p1275
+ boost.process documentation https://www.boost.org/libs/process 
+ Standard Library wishlist (Matt Austern) https://docs.google.com/document/d/1AC3vkOgFezPaeSZO-fvxgwzEIabw8I_seE7yFG_16Bk/preview
+ cppcast with Klemens on boost.process https://channel9.msdn.com/Shows/CppCast/Episode-72-BoostProcess-with-Klemens-Morgenstern
+ Pacific c++ Klemens on boost.process design https://www.youtube.com/watch?v=uZ4IG1OfeR0

