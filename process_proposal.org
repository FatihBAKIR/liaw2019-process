
#+Revision: 0
#+Audience: LEWGI
#+Status: 
#+Group: WG21
#+Title: A proposal to add process management to the C++ standard library
#+Author: 
#+Email: 

* Revision History
** Revision 0
Initial release.

* Introduction

The creation and management of processes is a widely used and fundamental tool in computing systems.  Unfortunately C++ does not have a portable way to create and manage child processes.  Most other langauge standard libraries support facilities to wrap the complexities in support of application programmers.

The proposal is based on boost.process https://www.boost.org/libs/process which provides cross-platform implementation experience.

* Motivation and Scope

We propose a library to facilitate the following basic functionality:
+    create child processes on current machine
+    setup streams for communication with child std::out and std::err
+    communicate with child processes through streams
+    wait for processes to exit 
+    terminate processes

The following illustrates an example usage of the proposed library. 

#+BEGIN_SRC c++

#include <process>

int main()
{

  std::process_args args { "--version", "--std=c++2a" };

  try {
    std::ipstream pipe_stream;
    std::process child("gcc", args,
                          std_out > pipe_stream);

    std::string line;

    while (pipe_stream && std::getline(pipe_stream, line) && !line.empty()) 
    {
        std::cerr << line << std::endl;
    }
    child.wait();
  }
  catch(const std::exception& e) 
  {
     std::cerr << e.what();
  }
}

#+END_SRC

* Terminology
** Processes

** Process Groups

** Pipes

** Environment and Command Line Arguments

Issue: does windows allow passing the environment at start without altering the parent

Isabella Muerte 
Desert Sessions: Improving hostile environment interactions http://wg21.link/p1275

* Use Cases
* Survey of facilities in other standard libraries
** Java

#+BEGIN_SRC java

// ProcessBuilder takes variadic string arguments
// or a List<String>
var builder = new ProcessBuilder("/bin/cat", "-");

// start()-method will spawn the process
// Standard streams are piped automatically
Process p = builder.start();

// Write into process stdin
new OutputStreamWriter(p.getOutputStream())
      .write("foo\n")
      .close(); // close() needed to flush the buffer

// Read from stdout
var reader = new BufferedReader(
      new InputStreamReader(p.getInputStream()));
String output = reader.readLine();

assert output == "foo";

System.out.println("Exited with " + p.exitValue())

#+END_SRC

** Python

#+BEGIN_SRC python
from subprocess import Popen, PIPE

# Command line arguments are all passed in a single list
# Standard streams aren't piped by default
child = Popen([ '/bin/cat', '-' ],
          stdin=PIPE, stdout=PIPE, stderr=PIPE)

# communicate() takes input (optional)
# Waits for process to terminate
# Handles to standard streams aren't available
out, err = child.communicate(input='foo\n')
assert out == 'foo'
print("Exited with", child.returncode)

#+END_SRC

** Rust

#+BEGIN_SRC rust
use std::process::{Command, Stdio};

let mut child = Command("/bin/cat")
                .arg("-") // .args() also available, taking a range
                          // strings passed to .arg() are escaped
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .spawn()?; // ?-operator is for error handling
child.stdin.as_mut()?.write_all(b"foo\n")?;
// .wait_with_output() will, well, wait
// child.stdout/stderr exposes standard streams directly
let output = child.wait_with_output()?;
assert_eq!(b"foo", output.stdout.as_slice());
println!("Exited with {}", output.status.code.unwrap());

#+END_SRC

** Nodejs

#+BEGIN_SRC js

const { spawn } = require('child_process');

// First argument is argv[0], rest of argv passed in a list
const p = spawn('/bin/cat', ['-']);
p.stdin.write('foo\n');
// Idiomatic node.js uses callbacks everywhere
p.stdout.on('data', (data) => {
  assert.StrictEqual(data, 'foo\n');
});
p.on('close', (code) => {
  console.log(`Exited with ${code}`);
});

#+END_SRC

** Fortran
* Design 
** Core language impact
Bryce to provide information to Jeff
** Header <process>

** Start of execution
Have a run() method versus immdietied in the consructions
** Using a build method to create

** Handling of parameters
   There's an issue of escaping the argument properly
** Native Operating System Handle

The solution provides access to the operating system like std::thread for programmers that which to go beyond the provided facilities.

** Portable callbacks during spawn
*** onError -- does this change into a non-exception
*** onSuccess
*** onSetup
** EOF on pipe close
** Security and User Management Implications

** Bikeshed on .wait name
** Error Handling

** Synchronous Versus Asynchronous

** Integration of iostreams and pipes

* Synopsis 
* References
+ Isabella Muerte Desert Sessions: Improving hostile environment interactions http://wg21.link/p1275
+ boost.process documentation https://www.boost.org/libs/process 



